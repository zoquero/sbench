.\" Manpage for sbench.
.\" Contact zoquero@gmail.com to correct errors or typos.
.TH sbench 1 "07 Nov 2016" "1.0" "sbench man page"
.SH NAME
sbench \- Simple benchmarks.
.SH SYNOPSIS
sbench (-v) -t [cpu|mem|disk_w|disk_r_seq|disk_r_ran|ping|http_get (-w [warnThreshold] -c [critThreshold]) -p [PARAMS]

sbench (-v) -t cpu        (-w warnThreshold -c critThreshold) -p <times>

sbench (-v) -t cpu        (-w warnThreshold -c critThreshold) -p <times,numThreads>

sbench (-v) -t mem        (-w warnThreshold -c critThreshold) -p <times,sizeInBytes>

sbench (-v) -t disk_w     (-w warnThreshold -c critThreshold) -p <times,sizeInBytes,folderName>

sbench (-v) -t disk_w     (-w warnThreshold -c critThreshold) -p <times,sizeInBytes,numThreads,folderName>

sbench (-v) -t disk_r_seq (-w warnThreshold -c critThreshold) -p <times,sizeInBytes,fileName>

sbench (-v) -t disk_r_ran (-w warnThreshold -c critThreshold) -p <times,sizeInBytes,fileName>

sbench (-v) -t disk_r_ran (-w warnThreshold -c critThreshold) -p <times,sizeInBytes,numThreads,fileName>

sbench (-v) -t ping       (-w warnThreshold -c critThreshold) -p <times,sizeInBytes,dest>

sbench (-v) -t http_get   (-w warnThreshold -c critThreshold) -p <httpRef,url>

.SH DESCRIPTION

Measures how systems perform doing these tests:

* Memory: allocate, commit and set

* CPU: multi-threaded floating-point operations (simply sums, substractions, powers and divisions)

* Disk (filesystem):
    * Sequential read
    * Sequential write
    * Multi-threaded random write

* Network:
    * Latency: round-trip time by ICMP echo request 
    * Throughput: HTTP GET

You can find suites for benchmarking like hardinfo (https://github.com/lpereira/hardinfo/) or Phoronix Test Suite (http://www.phoronix-test-suite.com/) but this is simply a bunch of simple and reproducible tests that can be easily understood. For example, when testing CPU it just performs some simple floating-point operations that any i386 could do (sums, substractions, powers and divisions). It just tests more or less if the system is having CPU cycles (think about "CPU Ready" and "Co-Stop" on vSphere). If you are looking for a more complex CPU tests then you may be looking for specs like the ones from SPEC CPU Benchmark (https://www.spec.org/cpu/).

You can use sbench to extract a simple baseline of your systems (on idle!), so that you if you have performance problems on your 'pets' you will be able to (stop services first! sig) extract it again to realize if it's your application or the IaaS who is inducing the problem.

Take care when using it. Having several threads writing on a file can generate hundreds of IOPS that can affect negatively the performance of other systems. Fortunately you can adjust finely the tests.

Using the command line interface you can set threshold parameters and the output will then be nagios plugin-like, so that you will be able to integrate it with your nagios-compatible monitoring system. Remember that with great power there must also come great responsibility :) be awared again that you may induce heavy load and you could affect the performance of your systems.

.SH SOURCE
It can be found at GitHub: https://github.com/zoquero/simplebenchmark/

.SH DISCLAIMER
I (the author) release myself from responsibility for any problem in the performance of your applications that it could create.

.SH EXIT STATUS
If you specify thresholds in the command line it will return 0, 1, 2, 3 respectively if "ok", "warning", "critical", unknown".

If you don't set specify the thresholds then if everything worked will return 0, else != 0.

.SH ENVIRONMENT
libcurl uses http_proxy environment variable if set.

.SH EXAMPLES
* To allocate&commit 10 MiB of RAM and memset it 10 times
      and get a response in nagios plugin-like format:
  sbench -t mem -p 10,104857600 -w 0.3 -c 0.5

* To have 2 threads doing 100E6 silly calculus (2 pows):
  sbench -t cpu -p 10000000,2

* To create 4 threads each writing 10 MiB in a file in 4k blocks:
  sbench -t disk_w -p 2560,4096,4,/tmp/_sbench.d

* To read sequentially 100 MiB from a file in 4k blocks:
  sbench -t disk_r_seq -p 25600,4096,/tmp/_sbench.testfile

* To read by random access 100 MiB from a file
      by 2 threads in 4k blocks:
  sbench -t disk_r_ran -p 25600,4096,2,/tmp/_sbench.testfile

* To get the mean round-trip time sending
      4 ICMP echo request to ahost.adomain.net:
  sbench -t ping -p 4,56,ahost.adomain.net

* To download by HTTP GET http://www.test.com/file ,
      and to compare it with the reference:
      file 'my_ref_file' located at /var/lib/sbench/http_refs :
  sbench -t http_get -p my_ref_file,http://www.test.com/file

.SH SEE ALSO
iostat(1), top(1), sar(1) 

.SH BUGS
No known bugs. You can report them at https://github.com/zoquero/simplebenchmark/issues

.SH AUTHOR
Angel Galindo Mu√±oz (zoquero@gmail.com)
